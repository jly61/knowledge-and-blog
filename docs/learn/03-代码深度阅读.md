# é˜¶æ®µ 4ï¼šä»£ç æ·±åº¦é˜…è¯»

## ğŸ“š å­¦ä¹ ç›®æ ‡

æ·±å…¥ç†è§£å…³é”®ä»£ç çš„å®ç°ç»†èŠ‚ï¼ŒæŒæ¡æ ¸å¿ƒç®—æ³•å’Œè®¾è®¡æ¨¡å¼ã€‚

## ğŸ¯ å­¦ä¹ æ¸…å•

- [ ] åŒå‘é“¾æ¥è§£æç®—æ³•
- [ ] çŸ¥è¯†å›¾è°±æ•°æ®ç”Ÿæˆ
- [ ] Markdown ç¼–è¾‘å™¨å®ç°
- [ ] æœç´¢ç®—æ³•
- [ ] æ–‡ä»¶ç³»ç»Ÿæ ‘å½¢ç»“æ„æ„å»º

---

## 1. åŒå‘é“¾æ¥è§£æç®—æ³•

### ğŸ“ å…³é”®æ–‡ä»¶

- `lib/markdown/parseLinks.ts` - é“¾æ¥è§£æ
- `app/actions/notes.ts` - é“¾æ¥åˆ›å»º

### ğŸ” ä»£ç è§£æ

#### 1.1 é“¾æ¥è§£æ

```typescript
// lib/markdown/parseLinks.ts
export function parseLinks(content: string): string[] {
  // æ­£åˆ™åŒ¹é… [[ç¬”è®°æ ‡é¢˜]]
  const linkRegex = /\[\[([^\]]+)\]\]/g
  const links: string[] = []
  let match
  
  while ((match = linkRegex.exec(content)) !== null) {
    links.push(match[1].trim())
  }
  
  return [...new Set(links)] // å»é‡
}
```

**è¦ç‚¹**ï¼š
- ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é… `[[...]]` è¯­æ³•
- æå–ç¬”è®°æ ‡é¢˜
- å»é‡å¤„ç†

#### 1.2 é“¾æ¥å…³ç³»åˆ›å»º

```typescript
// app/actions/notes.ts
async function createLinks(
  noteId: string, 
  links: string[], 
  noteTitleMap: Map<string, string>
) {
  // 1. åˆ é™¤æ—§é“¾æ¥
  await db.link.deleteMany({ where: { fromNoteId: noteId } })
  
  // 2. åˆ›å»ºæ–°é“¾æ¥
  for (const linkTitle of links) {
    const toNoteId = noteTitleMap.get(linkTitle.toLowerCase())
    if (toNoteId && toNoteId !== noteId) {
      await db.link.create({
        data: {
          fromNoteId: noteId,
          toNoteId: toNoteId,
        },
      })
    }
  }
}
```

**è¦ç‚¹**ï¼š
- å…ˆåˆ é™¤æ—§é“¾æ¥ï¼Œå†åˆ›å»ºæ–°é“¾æ¥
- ä½¿ç”¨ Map å¿«é€ŸæŸ¥æ‰¾ç¬”è®° ID
- é¿å…è‡ªé“¾æ¥

#### 1.3 åå‘é“¾æ¥ç”Ÿæˆ

**åŸç†**ï¼šPrisma å…³ç³»è‡ªåŠ¨å¤„ç†
```prisma
model Link {
  fromNote   Note   @relation("FromLinks", fields: [fromNoteId], references: [id])
  toNote     Note   @relation("ToLinks", fields: [toNoteId], references: [id])
}
```

**å®è·µ**ï¼šç†è§£å…³ç³»æŸ¥è¯¢
```typescript
const note = await db.note.findUnique({
  where: { id },
  include: {
    links: { include: { toNote: true } },      // æ­£å‘é“¾æ¥
    backlinks: { include: { fromNote: true } }, // åå‘é“¾æ¥
  },
})
```

---

## 2. çŸ¥è¯†å›¾è°±æ•°æ®ç”Ÿæˆ

### ğŸ“ å…³é”®æ–‡ä»¶

- `app/actions/graph.ts` - å›¾è°±æ•°æ®ç”Ÿæˆ
- `components/graph/graph-client.tsx` - å›¾è°±æ¸²æŸ“

### ğŸ” ä»£ç è§£æ

#### 2.1 æ•°æ®ç”Ÿæˆé€»è¾‘

```typescript
// app/actions/graph.ts
export async function getGraphData(filters?: GraphFilters) {
  // 1. è·å–æ‰€æœ‰ç¬”è®°
  const notes = await db.note.findMany({
    where: { userId: user.id, ...filterConditions },
    include: { category: true, tags: true },
  })
  
  // 2. è·å–æ‰€æœ‰é“¾æ¥å…³ç³»
  const links = await db.link.findMany({
    where: {
      fromNote: { userId: user.id },
      ...filterConditions,
    },
  })
  
  // 3. æ„å»ºèŠ‚ç‚¹
  const nodes = notes.map(note => ({
    id: note.id,
    label: note.title,
    // ... å…¶ä»–å±æ€§
  }))
  
  // 4. æ„å»ºè¾¹
  const edges = links.map(link => ({
    from: link.fromNoteId,
    to: link.toNoteId,
  }))
  
  return { nodes, edges }
}
```

**è¦ç‚¹**ï¼š
- èŠ‚ç‚¹ = ç¬”è®°
- è¾¹ = é“¾æ¥å…³ç³»
- æ”¯æŒæŒ‰åˆ†ç±»/æ ‡ç­¾ç­›é€‰

#### 2.2 å¯è§†åŒ–æ¸²æŸ“

```typescript
// components/graph/graph-client.tsx
useEffect(() => {
  const data = { nodes, edges }
  const options = {
    physics: {
      enabled: true,
      stabilization: { iterations: 200 },
    },
    // ... å…¶ä»–é…ç½®
  }
  
  const network = new Network(containerRef.current, data, options)
  
  // èŠ‚ç‚¹ç‚¹å‡»äº‹ä»¶
  network.on("click", (params) => {
    if (params.nodes.length > 0) {
      router.push(`/notes/${params.nodes[0]}`)
    }
  })
}, [nodes, edges])
```

---

## 3. Markdown ç¼–è¾‘å™¨å®ç°

### ğŸ“ å…³é”®æ–‡ä»¶

- `components/editor/markdown-split-editor.tsx` - åˆ†å±ç¼–è¾‘å™¨

### ğŸ” ä»£ç è§£æ

#### 3.1 åˆ†å±å¸ƒå±€

```typescript
<div className="grid grid-cols-2 gap-4">
  {/* å·¦ä¾§ç¼–è¾‘åŒº */}
  <div className="border rounded-lg">
    <TiptapEditor
      content={content}
      onChange={setContent}
    />
  </div>
  
  {/* å³ä¾§é¢„è§ˆåŒº */}
  <div className="border rounded-lg overflow-auto">
    <ReactMarkdown>{content}</ReactMarkdown>
  </div>
</div>
```

#### 3.2 åŒæ­¥æ»šåŠ¨

```typescript
// ç›‘å¬ç¼–è¾‘åŒºæ»šåŠ¨
const handleEditorScroll = (e: React.UIEvent<HTMLDivElement>) => {
  const scrollPercent = e.currentTarget.scrollTop / 
    (e.currentTarget.scrollHeight - e.currentTarget.clientHeight)
  
  // åŒæ­¥åˆ°é¢„è§ˆåŒº
  previewRef.current.scrollTop = scrollPercent * 
    (previewRef.current.scrollHeight - previewRef.current.clientHeight)
}
```

---

## 4. æœç´¢ç®—æ³•

### ğŸ“ å…³é”®æ–‡ä»¶

- `app/actions/search.ts` - æœç´¢é€»è¾‘

### ğŸ” ä»£ç è§£æ

```typescript
export async function searchNotes(
  query: string,
  filters?: SearchFilters
) {
  const where: Prisma.NoteWhereInput = {
    userId: user.id,
    // å…¨æ–‡æœç´¢
    OR: [
      { title: { contains: query, mode: 'insensitive' } },
      { content: { contains: query, mode: 'insensitive' } },
    ],
  }
  
  // åˆ†ç±»ç­›é€‰
  if (filters?.categoryId) {
    where.categoryId = filters.categoryId
  }
  
  // æ ‡ç­¾ç­›é€‰
  if (filters?.tagIds?.length) {
    where.tags = {
      some: { id: { in: filters.tagIds } },
    }
  }
  
  return await db.note.findMany({
    where,
    include: { category: true, tags: true },
    orderBy: { updatedAt: 'desc' },
  })
}
```

**è¦ç‚¹**ï¼š
- ä½¿ç”¨ Prisma çš„ `contains` è¿›è¡Œæ¨¡ç³Šæœç´¢
- æ”¯æŒå¤šæ¡ä»¶ç»„åˆ
- ä½¿ç”¨ `OR` å®ç°å¤šå­—æ®µæœç´¢

---

## 5. æ–‡ä»¶ç³»ç»Ÿæ ‘å½¢ç»“æ„æ„å»º

### ğŸ“ å…³é”®æ–‡ä»¶

- `app/actions/interview.ts` - æ–‡ä»¶ç³»ç»Ÿè¯»å–

### ğŸ” ä»£ç è§£æ

```typescript
async function readDirectory(
  dirPath: string,
  parentPath: string = ""
): Promise<InterviewNode[]> {
  const items = await fs.readdir(dirPath, { withFileTypes: true })
  const nodes: InterviewNode[] = []
  
  for (const item of items) {
    const fullPath = path.join(dirPath, item.name)
    const relativePath = path.join(parentPath, item.name)
    
    if (item.isDirectory()) {
      // é€’å½’è¯»å–å­ç›®å½•
      const children = await readDirectory(fullPath, relativePath)
      nodes.push({
        type: 'folder',
        name: item.name,
        path: relativePath,
        children,
      })
    } else if (item.isFile() && item.name.endsWith('.md')) {
      nodes.push({
        type: 'file',
        name: item.name,
        path: relativePath.replace(/\.md$/, ''),
      })
    }
  }
  
  return sortByOrder(nodes) // è‡ªå®šä¹‰æ’åº
}
```

**è¦ç‚¹**ï¼š
- é€’å½’è¯»å–ç›®å½•ç»“æ„
- è¿‡æ»¤é Markdown æ–‡ä»¶
- è‡ªå®šä¹‰æ’åºï¼ˆæŒ‰æ–‡ä»¶åå‰ç¼€ï¼‰

---

## âœ… é˜¶æ®µ 4 å®Œæˆæ£€æŸ¥

- [ ] èƒ½è§£é‡ŠåŒå‘é“¾æ¥è§£æç®—æ³•
- [ ] ç†è§£çŸ¥è¯†å›¾è°±æ•°æ®ç”Ÿæˆé€»è¾‘
- [ ] çŸ¥é“ Markdown ç¼–è¾‘å™¨çš„å®ç°åŸç†
- [ ] ç†è§£æœç´¢ç®—æ³•çš„å®ç°
- [ ] èƒ½è§£é‡Šæ–‡ä»¶ç³»ç»Ÿæ ‘å½¢ç»“æ„æ„å»º

## ğŸ“ å®è·µä»»åŠ¡

1. **ä»£ç æ³¨é‡Š**ï¼šä¸ºå…³é”®å‡½æ•°æ·»åŠ è¯¦ç»†æ³¨é‡Š
2. **ç®—æ³•ä¼˜åŒ–**ï¼šæ€è€ƒå¦‚ä½•ä¼˜åŒ–ç°æœ‰ç®—æ³•
3. **åŠŸèƒ½æ‰©å±•**ï¼šåŸºäºç°æœ‰ä»£ç æ·»åŠ æ–°åŠŸèƒ½

## â¡ï¸ ä¸‹ä¸€æ­¥

å®Œæˆé˜¶æ®µ 4 åï¼Œç»§ç»­å­¦ä¹ ï¼š
ğŸ‘‰ [04-å®è·µä»»åŠ¡.md](./04-å®è·µä»»åŠ¡.md)

